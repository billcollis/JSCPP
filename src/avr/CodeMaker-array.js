"use strict";
var CodeMaker;

CodeMaker = function(bdMicro) {

    // places to write the autogenerated code
    this.codeArr = [];
    this.projectname = "";
    this.username = "";
    this.crystal = 16000000;
    this.baud = 9600;
    this.hasInputs = false;
    this.hasADC = false;
    this.hasSerialOut = true;
    this.hasCharLCD = false;
    this.globalvars = ["uint8_t i=10;", "uint16_t j = 32000;"];
    this.bdMicro = bdMicro;

    return this;
}
CodeMaker.prototype.getFullCode = function () {

    this.codeArr.length = 0;
    this.codeArr = this.header();
    this.codeArr = this.codeArr.concat(this.iomacros());
    this.codeArr = this.codeArr.concat(this.adcconfig());
    this.codeArr = this.codeArr.concat(this.serialoutput());
    this.codeArr = this.codeArr.concat(this.addFuncPrototypes());
    this.codeArr = this.codeArr.concat(this.addGlobalVars());
    this.codeArr = this.codeArr.concat(this.buildMainStart());
    this.codeArr = this.codeArr.concat(this.ioconfigs());
    this.codeArr.push("while(1)");
    this.codeArr.push("{");
    this.codeArr.push("} //end while(1)");
    this.codeArr.push("}   //end of main");
    return this.codeArr;
}

CodeMaker.prototype.getDateTime = function () {
    var currentTime = new Date();
    var hour = currentTime.getHours();
    var min = currentTime.getMinutes();
    var day = currentTime.getDate()
    var month = currentTime.getMonth() + 1;
    var year = currentTime.getFullYear()
    return day + "/" + month + "/" + year + "  " + hour + ":" + min;
}

CodeMaker.prototype.header = function () {
    var code = [];
    code.push("/**********************************************/")
    code.push("// Project Name: " + this.projectname)
    code.push("// Author: " + this.username)
    code.push("// Date: " + this.getDateTime())
    code.push("// Code auto-generated by System Designer from www.techideas.co.nz");
    code.push("");
    code.push("/**********************************************/")
    code.push("//Hardware defines")
    code.push("//make sure your oscillator setting (or crystal) matches this ")
    code.push("#define F_CPU " + this.crystal)
    code.push("#define BAUD " + this.baud)
    code.push("#define BRGEN F_CPU/16/BAUD-1")
    code.push("")
    code.push("/**********************************************/")
    code.push("//Header files with various functions")
    code.push("#include <avr/io.h>")
    code.push("#include <stdint.h>")
    code.push("#include <util/delay.h>")
    code.push("#include <avr/interrupt.h>")
    code.push("#include <avr/eeprom.h>")
    code.push("#include <stdio.h>")
    code.push("#include <string.h>")
    code.push("#include <avr/pgmspace.h>")
    return code;
}
CodeMaker.prototype.iomacros = function () {
    var code = [];
    code.push("/**********************************************/");
    code.push("//Hardware macros for outputs");
    olinks = this.bdMicro.getOutgoingLinks();
    for (var i = 0; i < olinks.length; i++) {
        code.push("#define " + "set_" + olinks[i].getDestination().getText() + "()   PORT" + getMicroPort(olinks[i], false, 0) + " |= (1<<P" + getMicroPort(olinks[i], false, 0) + getMicroPort(olinks[i], false, 2) + ")    //force output high");
        code.push("#define " + "clr_" + olinks[i].getDestination().getText() + "()   PORT" + getMicroPort(olinks[i], false, 0) + " &= ~(1<<P" + getMicroPort(olinks[i], false, 0) + getMicroPort(olinks[i], false, 2) + ")    //force output low");
        code.push("#define " + "toggle_" + olinks[i].getDestination().getText() + "()   PORT" + getMicroPort(olinks[i], false, 0) + " ^= (1<<P" + getMicroPort(olinks[i], false, 0) + getMicroPort(olinks[i], false, 2) + ")    //toggle output");
    }
    //Array.forEach(olinks, function (link) //requires AJAX
    //{
    //    code.push("#define " + "set_" + link.getDestination().getText() + "()   PORT" + getMicroPort(link, false, 0) + " |= (1<<P" + getMicroPort(link, false, 0) + getMicroPort(link, false, 2) + ")    //force output high");
    //    code.push("#define " + "clr_" + link.getDestination().getText() + "()   PORT" + getMicroPort(link, false, 0) + " &= ~(1<<P" + getMicroPort(link, false, 0) + getMicroPort(link, false, 2) + ")    //force output low");
    //    code.push("#define " + "toggle_" + link.getDestination().getText() + "()   PORT" + getMicroPort(link, false, 0) + " ^= (1<<P" + getMicroPort(link, false, 0) + getMicroPort(link, false, 2) + ")    //toggle output");
    //});
    code.push("//Hardware macros for inputs");
    for (var i = 0; i < ilinks.length; i++) {
        if (ilinks[i].getOrigin().getId().indexOf("switch") > 0) {
            this.hasInputs = true;
            code.push("#define " + ilinks[i].getOrigin().getText() + "_IsLow()   ~PIN" + getMicroPort(ilinks[i], true, 0) + " & (1<<P" + getMicroPort(ilinks[i], true, 0) + getMicroPort(ilinks[i], true, 2) + ")    //true if pin is low");
            code.push("#define " + ilinks[i].getOrigin().getText() + "_IsHigh()   PIN" + getMicroPort(ilinks[i], true, 0) + " & (1<<P" + getMicroPort(ilinks[i], true, 0) + getMicroPort(ilinks[i], true, 2) + ")    //true if pin is high");
        }
    }

    //Array.forEach(ilinks, function (link) {
    //    if (link.getOrigin().getId().indexOf("switch") > 0) {
    //        hasInputs = true;
    //        code.push("#define " + link.getOrigin().getText() + "_IsLow()   ~PIN" + getMicroPort(link, true, 0) + " & (1<<P" + getMicroPort(link, true, 0) + getMicroPort(link, true, 2) + ")    //true if pin is low");
    //        code.push("#define " + link.getOrigin().getText() + "_IsHigh()   PIN" + getMicroPort(link, true, 0) + " & (1<<P" + getMicroPort(link, true, 0) + getMicroPort(link, true, 2) + ")    //true if pin is high");
    //    }
    //});
    code.push("//Hardware macros for ADC inputs");
    for (var i = 0; i < ilinks.length; i++) {
        if (ilinks[i].getOrigin().getId().indexOf("analog") > 0) {
            this.hasADC = true;
            this.hasInputs = true;
            code.push("#define " + ilinks[i].getOrigin().getText() + " " + getMicroPort(ilinks[i], true, 2) + "     //macro to refer to ADC channel"); //only goes by pin# at the moment which isn't correct for tiny45
        }
    }

    //Array.forEach(ilinks, function (link) {
    //    if (link.getOrigin().getId().indexOf("analog") > 0) {
    //        hasADC = true;
    //        hasInputs = true;
    //        code.push("#define " + link.getOrigin().getText() + " " + getMicroPort(link, true, 2) + "     //macro to refer to ADC channel"); //only goes by pin# at the moment which isn't correct for tiny45
    //    }
    //});
    return code;
}
CodeMaker.prototype.adcconfig = function () {
    var code = [];
    if (this.hasADC) {
        code.push("");
        code.push("/**********************************************/");
        code.push("//Configure ADC");
        code.push("void init_ADC()");
        code.push("{");
        code.push("//At 16MHZ set prescaler to 128 to get 125Khz clock");
        code.push("ADCSRA |= ((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0));");
        code.push("//At 1MHz set prescaler to 8 to get 125Khz clock");
        code.push("//ADCSRA |= ((1<<ADPS1)|(1<<ADPS0));");
        code.push("//AVcc as voltage reference with external capacitor on ARef");
        code.push("//ADMUX |= (1<<REFS1);      //uncomment this line for internal voltage");
        code.push("ADMUX |= (1<<REFS0);");
        code.push("ADCSRA |= (1<<ADEN);       //Power on the ADC");
        code.push("ADCSRA |= (1<<ADSC);       //Start initial conversion");
        code.push("}");
        code.push("// get a single adc reading from one channel");
        code.push("uint16_t read_adc(uint8_t channel)");
        code.push("{");
        code.push("ADMUX &= 0xF0;                  //Clear previously read channel");
        code.push("ADMUX |= channel;               //Set to new channel to read");
        code.push("ADCSRA |= (1<<ADSC);            //Starts a new conversion");
        code.push("while(ADCSRA & (1<<ADSC));      //Wait until the conversion is done");
        code.push("return ADCW;                    //Returns the value from the channel");
        code.push("}");
    }
    return code;
}
CodeMaker.prototype.serialoutput = function () {
    var code = [];
    if (this.hasSerialOut) {
        code.push("/**********************************************/");
        code.push("// Setup serial port to send serial data");
        code.push("void init_USART()");
        code.push("{");
        code.push("UBRR0H = (char)(BRGEN>>8); //Set baud rate");
        code.push("UBRR0L = (char) BRGEN; //Set baud rate");
        code.push("UCSR0C |= (1<<USBS0) //2 stopbits");
        code.push("UCSR0C |= (3<<UCSZ00); // 8data");
        code.push("//UCSR0C |= (1 << UPM01) //parity");
        code.push("//UCSR0C |= (1 << UPM00) //odd parity");
        code.push("UCSR0B = (1<<TXEN0);        // Enable transmitter only");
        code.push("}");
        code.push("/**********************************************/");
        code.push("//Send 1 byte of data");
        code.push("void usart_tx(unsigned char data)");
        code.push("{");
        code.push("//UDRE0 is set when buffer is empty, cleared while transmitting data");
        code.push("//must default to 1 when TXEN0 is set");
        code.push("while (!( UCSR0A & (1<<UDRE0))) // While not 1 wait (1 is data reg empty)");
        code.push("{");
        code.push("}");
        code.push("UDR0 = data;// Put data into buffer, sends the data");
        code.push("}");
        code.push("");
    }
    return code;
}
CodeMaker.prototype.addFuncPrototypes = function () {
    var code = [];
    code.push("/**********************************************/");
    code.push("//Function Prototypes");
    code.push("");
    return code;
}

CodeMaker.prototype.addGlobalVars = function () {
    var code = [];
    code.push("/**********************************************/");
    code.push("//Declare & initialise global variables");
    for (i in this.globalvars) {
        code.push[i];
    }
    code.push("");
    return code;
}

CodeMaker.prototype.ioconfigs = function () {
    var code = [];
    code.push("");
    code.push("// Input & Output Hardware setups");
    code.push("// Initially make all micro pins outputs");
    $.each(microRegisters, function (key, txt) {
        if (txt.name.indexOf("DDR") >= 0)
            code.push(txt.name + " = 0xff;             //make all the pins on the port outputs");
    });
    if (this.hasInputs) {
        code.push("// Then make these pins inputs");
        $.each(ilinks, function (key, link) {
            code.push("DDR" + getMicroPort(link, true, 0) + " &= ~(1<<P" + getMicroPort(link, true, 0) + getMicroPort(link, true, 2) + ");    //set pin to input");
        });
    }
    $.each(ilinks, function (key, link) {
        if (link.getOrigin().getId().indexOf("switch") > 0) {
            code.push("PORT" + getMicroPort(link, true, 0) + " |= (1<<P" + getMicroPort(link, true, 0) + getMicroPort(link, true, 2) + ");    //activate internal pullup resistor for " + link.getOrigin().getText());
        }
    });
    code.push("");
    return code;
}

CodeMaker.prototype.buildMainStart = function () {
    var code = [];
    code.push("/**********************************************/");
    code.push("//Main Program starts here");
    code.push("int main(void)");
    code.push("{");
    code.push("// Initial hardware setups go here");
    if (this.hasADC) {
        code.push("init_ADC(); //setup the ADC to work");
    }
    if (this.hasSerialOut) {
        code.push("init_USART(); //setup the TXD to work");
    }
    code.push("");
    return code;
}
