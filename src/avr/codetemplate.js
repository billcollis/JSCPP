"use strict";
// places to write the autogenerated code
var codeArr = [];
var projectname="";
var username="";
var crystal = 16000000;
var baud = 9600;
var hasInputs = false;
var hasADC = false;
var hasSerialOut = true;
var hasCharLCD = false;
var globalvars = ["uint8_t i=10;", "uint16_t j = 32000;"];

function makeCode() {
    if (bdMicro !== null)
    {
        codeArr.length = 0;
        header();
        iomacros();
        adcconfig();
        serialoutput();
        addFuncPrototypes();
        addGlobalVars();
        buildMainStart();
        ioconfigs();
        codeArr.push("while(1)");
        codeArr.push("{");
        codeArr.push("} //end while(1)");
        codeArr.push("}   //end of main");
    }
}

function getDateTime()
{
    var currentTime = new Date();
    var hour = currentTime.getHours();
    var min = currentTime.getMinutes();
    var day = currentTime.getDate()
    var month = currentTime.getMonth() + 1;
    var year = currentTime.getFullYear()
    return day + "/" + month + "/" + year +"  "+ hour +":"+ min;
}

function header() {
    codeArr.push("/**********************************************/")
    codeArr.push("// Project Name: " + projectname )
    codeArr.push("// Author: " + username)
    codeArr.push("// Date: " + getDateTime())
    codeArr.push("// Code auto-generated by System Designer from www.techideas.co.nz");
    codeArr.push("");
    codeArr.push("/**********************************************/")
    codeArr.push("//Hardware defines")
    codeArr.push("//make sure your oscillator setting (or crystal) matches this ")
    codeArr.push("#define F_CPU " + crystal)
    codeArr.push("#define BAUD " + baud )
    codeArr.push("#define BRGEN F_CPU/16/BAUD-1" )
    codeArr.push("")
    codeArr.push("/**********************************************/")
    codeArr.push("//Header files with various functions")
    codeArr.push("//#include <avr/io.h>")
    codeArr.push("//#include <stdint.h>")
    codeArr.push("//#include <util/delay.h>")
    codeArr.push("//#include <avr/interrupt.h>")
    codeArr.push("//#include <avr/eeprom.h>")
    codeArr.push("//#include <stdio.h>")
    codeArr.push("//#include <string.h>")
    codeArr.push("//#include <avr/pgmspace.h>")
}
function iomacros()
{
    codeArr.push("/**********************************************/");
    codeArr.push("//Hardware macros for outputs");
    olinks = bdMicro.getOutgoingLinks();
    for (var i = 0; i < olinks.length; i++)
    {
        codeArr.push("#define " + "set_" + olinks[i].getDestination().getText() + "()   PORT" + getMicroPort(olinks[i], false, 0) + " |= (1<<P" + getMicroPort(olinks[i], false, 0) + getMicroPort(olinks[i], false, 2) + ")    //force output high");
        codeArr.push("#define " + "clr_" + olinks[i].getDestination().getText() + "()   PORT" + getMicroPort(olinks[i], false, 0) + " &= ~(1<<P" + getMicroPort(olinks[i], false, 0) + getMicroPort(olinks[i], false, 2) + ")    //force output low");
        codeArr.push("#define " + "toggle_" + olinks[i].getDestination().getText() + "()   PORT" + getMicroPort(olinks[i], false, 0) + " ^= (1<<P" + getMicroPort(olinks[i], false, 0) + getMicroPort(olinks[i], false, 2) + ")    //toggle output");
    }
    //Array.forEach(olinks, function (link) //requires AJAX
    //{
    //    codeArr.push("#define " + "set_" + link.getDestination().getText() + "()   PORT" + getMicroPort(link, false, 0) + " |= (1<<P" + getMicroPort(link, false, 0) + getMicroPort(link, false, 2) + ")    //force output high");
    //    codeArr.push("#define " + "clr_" + link.getDestination().getText() + "()   PORT" + getMicroPort(link, false, 0) + " &= ~(1<<P" + getMicroPort(link, false, 0) + getMicroPort(link, false, 2) + ")    //force output low");
    //    codeArr.push("#define " + "toggle_" + link.getDestination().getText() + "()   PORT" + getMicroPort(link, false, 0) + " ^= (1<<P" + getMicroPort(link, false, 0) + getMicroPort(link, false, 2) + ")    //toggle output");
    //});
    codeArr.push("//Hardware macros for inputs");
    for (var i = 0; i < ilinks.length; i++)
    {
        if (ilinks[i].getOrigin().getId().indexOf("switch") > 0) {
            hasInputs = true;
            codeArr.push("#define " + ilinks[i].getOrigin().getText() + "_IsLow()   ~PIN" + getMicroPort(ilinks[i], true, 0) + " & (1<<P" + getMicroPort(ilinks[i], true, 0) + getMicroPort(ilinks[i], true, 2) + ")    //true if pin is low");
            codeArr.push("#define " + ilinks[i].getOrigin().getText() + "_IsHigh()   PIN" + getMicroPort(ilinks[i], true, 0) + " & (1<<P" + getMicroPort(ilinks[i], true, 0) + getMicroPort(ilinks[i], true, 2) + ")    //true if pin is high");
        }
    }

    //Array.forEach(ilinks, function (link) {
    //    if (link.getOrigin().getId().indexOf("switch") > 0) {
    //        hasInputs = true;
    //        codeArr.push("#define " + link.getOrigin().getText() + "_IsLow()   ~PIN" + getMicroPort(link, true, 0) + " & (1<<P" + getMicroPort(link, true, 0) + getMicroPort(link, true, 2) + ")    //true if pin is low");
    //        codeArr.push("#define " + link.getOrigin().getText() + "_IsHigh()   PIN" + getMicroPort(link, true, 0) + " & (1<<P" + getMicroPort(link, true, 0) + getMicroPort(link, true, 2) + ")    //true if pin is high");
    //    }
    //});
    codeArr.push("//Hardware macros for ADC inputs");
    for (var i = 0; i < ilinks.length; i++) {
        if (ilinks[i].getOrigin().getId().indexOf("analog") > 0) {
            hasADC = true;
            hasInputs = true;
            codeArr.push("#define " + ilinks[i].getOrigin().getText() + " " + getMicroPort(ilinks[i], true, 2) + "     //macro to refer to ADC channel"); //only goes by pin# at the moment which isn't correct for tiny45
        }
    }

    //Array.forEach(ilinks, function (link) {
    //    if (link.getOrigin().getId().indexOf("analog") > 0) {
    //        hasADC = true;
    //        hasInputs = true;
    //        codeArr.push("#define " + link.getOrigin().getText() + " " + getMicroPort(link, true, 2) + "     //macro to refer to ADC channel"); //only goes by pin# at the moment which isn't correct for tiny45
    //    }
    //});
}
function adcconfig()
{
    if (hasADC)
    {
        codeArr.push("");
        codeArr.push("/**********************************************/");
        codeArr.push("//Configure ADC");
        codeArr.push("void init_ADC()");
        codeArr.push("{");
        codeArr.push("//At 16MHZ set prescaler to 128 to get 125Khz clock");
        codeArr.push("ADCSRA |= ((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0));");
        codeArr.push("//At 1MHz set prescaler to 8 to get 125Khz clock");
        codeArr.push("//ADCSRA |= ((1<<ADPS1)|(1<<ADPS0));");
        codeArr.push("//AVcc as voltage reference with external capacitor on ARef");
        codeArr.push("//ADMUX |= (1<<REFS1);      //uncomment this line for internal voltage");
        codeArr.push("ADMUX |= (1<<REFS0);");
        codeArr.push("ADCSRA |= (1<<ADEN);       //Power on the ADC");
        codeArr.push("ADCSRA |= (1<<ADSC);       //Start initial conversion");
        codeArr.push("}");
        codeArr.push("// get a single adc reading from one channel");
        codeArr.push("uint16_t read_adc(uint8_t channel)");
        codeArr.push("{");
        codeArr.push("ADMUX &= 0xF0;                  //Clear previously read channel");
        codeArr.push("ADMUX |= channel;               //Set to new channel to read");
        codeArr.push("ADCSRA |= (1<<ADSC);            //Starts a new conversion");
        codeArr.push("while(ADCSRA & (1<<ADSC));      //Wait until the conversion is done");
        codeArr.push("return ADCW;                    //Returns the value from the channel");
        codeArr.push("}");
    }
}
function serialoutput()
{
    if (hasSerialOut) {
        codeArr.push("/**********************************************/");
        codeArr.push("// Setup serial port to send serial data");
        codeArr.push("void init_USART()");
        codeArr.push("{");
        codeArr.push("UBRR0H = (char)(BRGEN>>8); //Set baud rate");
        codeArr.push("UBRR0L = (char) BRGEN; //Set baud rate");
        codeArr.push("UCSR0C |= (1<<USBS0) //2 stopbits");
        codeArr.push("UCSR0C |= (3<<UCSZ00); // 8data");
        codeArr.push("//UCSR0C |= (1 << UPM01) //parity");
        codeArr.push("//UCSR0C |= (1 << UPM00) //odd parity");
        codeArr.push("UCSR0B = (1<<TXEN0);        // Enable transmitter only");
        codeArr.push("}");
        codeArr.push("/**********************************************/");
        codeArr.push("//Send 1 byte of data");
        codeArr.push("void usart_tx(unsigned char data)");
        codeArr.push("{");
        codeArr.push("//UDRE0 is set when buffer is empty, cleared while transmitting data");
        codeArr.push("//must default to 1 when TXEN0 is set");
        codeArr.push("while (!( UCSR0A & (1<<UDRE0))) // While not 1 wait (1 is data reg empty)");
        codeArr.push("{");
        codeArr.push("}");
        codeArr.push("UDR0 = data;// Put data into buffer, sends the data");
        codeArr.push("}");
        codeArr.push("");
    }
}
function addFuncPrototypes()
{
    codeArr.push("/**********************************************/");
    codeArr.push("//Function Prototypes");
    codeArr.push("");
}

function addGlobalVars()
{
    codeArr.push("/**********************************************/");
    codeArr.push("//Declare & initialise global variables");
    for (i in globalvars){
        codeArr.push[i];
    }
    codeArr.push("");
}

function ioconfigs()
{
    codeArr.push("");
    codeArr.push("// Input & Output Hardware setups");
    codeArr.push("// Initially make all micro pins outputs");
    $.each(microRegisters, function (key, txt) {
        if (txt.name.indexOf("DDR") >= 0)
            codeArr.push(txt.name + " = 0xff;             //make all the pins on the port outputs");
    });
    if (hasInputs) {
        codeArr.push("// Then make these pins inputs");
        $.each(ilinks, function (key,link) {
            codeArr.push("DDR" + getMicroPort(link, true, 0) + " &= ~(1<<P" + getMicroPort(link, true, 0) + getMicroPort(link, true, 2) + ");    //set pin to input");
        });
    }
    $.each(ilinks, function (key,link) {
        if (link.getOrigin().getId().indexOf("switch") > 0) {
            codeArr.push("PORT" + getMicroPort(link, true, 0) + " |= (1<<P" + getMicroPort(link, true, 0) + getMicroPort(link, true, 2) + ");    //activate internal pullup resistor for " + link.getOrigin().getText());
        }
    });
    codeArr.push("");
}

function buildMainStart() {
    codeArr.push("/**********************************************/");
    codeArr.push("//Main Program starts here");
    codeArr.push("int main(void)");
    codeArr.push("{");
    codeArr.push("// Initial hardware setups go here");
    if (hasADC) {
        codeArr.push("init_ADC(); //setup the ADC to work");
    }
    if (hasSerialOut) {
        codeArr.push("init_USART(); //setup the TXD to work");
    }
    codeArr.push("");
}
